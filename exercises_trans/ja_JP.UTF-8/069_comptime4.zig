//
// 'comptime'関数パラメータのより一般的な使用法の一つは、
// 関数に型を渡すことである。
//
//     fn foo(comptime MyType: type) void { ... }
//
// 実際には、型はコンパイル時にのみ利用可能であるため、
// ここでは 'comptime' キーワードが必要である。
//
// 用意された魔法使いの帽子をかぶる時間をとってください。
// これからこの能力を使って、ジェネリック関数を実装します。
//
//
const print = @import("std").debug.print;

pub fn main() void {
    // ここでは，コンパイル時に関数呼び出しから3種類の型とサイズの配列を宣言しています。
    // すっきりしましたね。
    const s1 = makeSequence(u8, 3);     // [3]u8 を生成します。
    const s2 = makeSequence(u32, 5);    // [5]u32を生成します。
    const s3 = makeSequence(i64, 7);    // [7]i64を生成します。

    print("s1={any}, s2={any}, s3={any}\n", .{ s1, s2, s3 });
}

// この関数は実行時に実行され、最終的にコンパイルされたプログラムの一部となるため、
// かなりワイルドです。
// この関数はデータのサイズと型が変化しない状態でコンパイルされます。
//
// さらに、異なるサイズと型も許容します。これは
// 逆説的な気がします。どうして両方が真になるのでしょうか？
//
// Zig コンパイラはこれを実現するために、サイズと型の組み合わせごとに関数の別コピーを生成しています。
// この場合、3つの異なる関数が生成され、それぞれが特定のデータサイズとデータ型を処理する
// マシンコードを持っています。
//
//
// この関数を修正して、'size' パラメータを変更してください。
//
//     1)  コンパイル時に既知であることが保証される．
//     2) T型配列（生成して返すシーケンス）のサイズを設定する．
//
//
fn makeSequence(comptime T: type, ??? size: usize) [???]T {
    var sequence: [???]T = undefined;
    var i: usize = 0;

    while (i < size) : (i += 1) {
        sequence[i] = @intCast(T, i) + 1;
    }

    return sequence;
}
