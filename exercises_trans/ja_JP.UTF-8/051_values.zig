//
// 前回の演習がディープダイブだと思った人は、帽子につかまって。
// これからコンピュータの溶けた核の中に潜っていくので
// 
//
// (Shouting)こちらへ。ビットとバイトはRAMからCPUに 
// 熱い高密度の流体のように流れる。その力は驚くべきものだ。
// しかし、これがZigプログラムのデータにどう関係するのか？
// テキストエディターで調べてみよう。
//
// ああ、これでいい。これで、見慣れたZigのコードを見ることができる。
//
// @import()は、インポートしたコードを自分のコードに追加する。この場合、
// 標準ライブラリのコードがあなたのプログラムに追加され、一緒にコンパイルされる。
// これらはすべて、実行時にRAMに読み込まれている。
// ああ、それから "const std "と名付けたもの。実はあれは構造体なのだ!
//
const std = @import("std");

// ちょっと前に見たRPGのキャラクター構造体を覚えているか？構造体は、実際には単なる
// メモリを扱う非常に便利な方法だ。キャラクター構造体のフィールド（gold,
// health, experience）は、すべて特定の大きさの値であり、
// それらを足すと、全体として構造体のサイズになる。

const Character = struct {
    gold: u32 = 0,
    health: u8 = 100,
    experience: u32 = 0,
};

// ここでは、"the_narrator" という名前のキャラクターを作成する。
// "the_narrator"はキャラクター構造体の「不変な」インスタンスだ。これは
// プログラム中にデータとして格納され、命令コードと同様に、プログラム実行時に
// RAM に読み込まれる。このデータのメモリ上の相対的な位置は、
// ハードコードされており、アドレスや値は変更されない。

const the_narrator = Character{
    .gold = 12,
    .health = 99,
    .experience = 9000,
};

// この「global_wizard」というキャラクターもよく似ている。
// const ではないため、このデータのアドレスは変更されないが、
// データ自体は変更可能である。

var global_wizard = Character{};

// 関数は、特定のアドレスにある命令コードだ。
// Zigにおける関数のパラメータは常に不変だ。それらは「スタック」に格納される。
// スタックはデータ構造の一種であり、「スタック」はあなたのプログラムのために予約された 
// RAM の特定のビットである。CPU は「スタック」に何かを追加したり削除したりするための
// 特別なサポートを持っているので、メモリストレージとして非常に効率的な場所である。
//
//
// また、関数が実行されるとき、入力された引数は多くの場合、
// レジスタでCPUの心臓部そのものにロードされる。
//
// ここで紹介する main() 関数には入力引数がないが、
// スタックエントリ（「フレーム」と呼ばれる）を持つことになる。

pub fn main() void {

    // ここで、glorpはスタック上に確保される。
    // なぜなら、glorpの各インスタンスは変更可能(mutable)であり、
    // この関数の呼び出しに固有であるからである。

    var glorp = Character{
        .gold = 30,
    };

    // "reward_xp" の値は面白い。これは変更不可(immutable)な値なので、
    // ローカルであっても、グローバルなデータに入れて、
    // すべての呼び出しの間で共有することができる。しかし、
    // このような小さな値なので、それが使われる命令コードでは、
    // 単にリテラル値としてインライン化することもできる。 
    // そこは、コンパイラ次第である。

    const reward_xp: u32 = 200;

    // さて、冒頭でインポートした "std "構造体の話に戻ろう。
    // インポートした後は普通のZig値なので、
    // そのフィールドや宣言に新しい名前を割り当てることもできる。
    // 「 debug 」は別の構造体を指し、
    // 「 print 」はその構造体の中にある名前空間付きのパブリック関数である。
    //
    // std.debug.print 関数を "print" という名前の const に割り当てて、
    // 後でこの新しい名前を使えるようにしよう。

    const print = ???;

    // 次に、Zigでの値の代入とポインティングについて見てみよう。
    //
    // ここでは、以下の3つの方法で、新しい名前を作ってアクセスする方法を試してみよう。
    // glorp Characterにアクセスするための新しい名前を作り、その値の一つを変更する。
    //
    // "glorp_access1 "の名前が間違っている! Zigに頼んで 
    // メモリを確保するようZigに依頼した。
    // つまり、glorpをglorp_access1に代入すると、実際にはすべてのフィールドを代入して
    // コピーしていることになる。これで、2つの別々のキャラクターができた。
    //
    // これは修正する必要はない。しかし、以下の他の2つの課題と比較して、
    // この課題ではプログラムの出力に何が表示されるかに注目しよう。
    // 

    var glorp_access1: Character = glorp;
    glorp_access1.gold = 111;
    print("1:{}!. ", .{glorp.gold == glorp_access1.gold});

    // 注意！:
    //
    //     もしこれを var の代わりに *const Character pointer で行おうとすると、
    //     変更する際にコンパイラーエラーが発生する。
    //     なぜなら const 値は不変だからだ!
    //
    // "glorp_access2 "は私たちが望むことをやってくれる。
    // これは、元のglorpのアドレスを指している。
    // また、構造体フィールドでは暗黙のうちに1回参照解除が行われるので、
    // glorp_access2 から "gold" フィールドにアクセスすると、
    // glorp自身からアクセスしたのと同じように見えることを覚えておいて。

    var glorp_access2: *Character = &glorp;
    glorp_access2.gold = 222;
    print("2:{}!. ", .{glorp.gold == glorp_access2.gold});

    // "glorp_access3 "は面白い。ポインタでもあるが、constになっている。
    // goldの値を変更することはできないのだろうか？
    // いや、そうではない。以前のポインタの実験で思い出したかもしれないが、
    // 定数ポインタは指しているものを変更することはできない。
    // しかし、そのポインタが指すアドレスの値ははまだ変更可能である! 

    const glorp_access3: *Character = &glorp;
    glorp_access3.gold = 333;
    print("3:{}!. ", .{glorp.gold == glorp_access3.gold});

    // 注意！:
    //
    //     もしこれを *const Character pointer で行おうとすると、
    //     うまくいかないはず。
    //     VALUE が不変になるため、コンパイラエラーが発生するため。
    //
    // 続き...
    //
    // 関数への引数の受け渡しは、ほとんど同じ。
    // (Zig は関数のパラメータはすべて const であることを強制するため）
    // 
    //
    // これを知った上で、levelUp()を期待通りに動作させられるかどうか見てみよう。
    // 与えられたキャラクターの経験値に指定された量を追加する。
    // 
    //
    print("XP before:{}, ", .{glorp.experience});

    // 修正1/2はこちら:
    levelUp(glorp, reward_xp);

    print("after:{}.\n", .{glorp.experience});
}

// 修正2/2はこちら:
fn levelUp(character_access: Character, xp: u32) void {
    character_access.experience += xp;
}

// そして、まだまだある！？
//
// プログラムデータをメモリに格納する場所は、データセグメント（コンパイル時に割り当てられる）と
// 「スタック」（実行時に割り当てられる）だけではない。
// ただ、最も効率的な場所なのである。
// プログラムが実行されるまで、どれだけのメモリを必要とするかわからないこともある。
// また、プログラムに割り当てられるスタックメモリのサイズには限界がある。  
// （多くの場合、オペレーティングシステムによって設定される）。
// このようなときのために、「ヒープ」を用意している。
//
// ヒープメモリは好きなだけ使えますが（もちろん物理的な制限の範囲内で）、
// スタックのように項目を追加したり削除したりするCPUのサポートが組み込まれていないため、
// 管理効率はかなり悪くなる。
// また、割り当ての種類によっては、プログラムはヒープメモリの使用を管理するために
// 高価な作業をしなければならないかもしれない。
// ヒープアロケータについては後で学ぼう。
//
// ふぅ〜。これは多くの情報だった。
// 次の演習では、すぐに使えるZig言語の機能を学ぼう
// 
