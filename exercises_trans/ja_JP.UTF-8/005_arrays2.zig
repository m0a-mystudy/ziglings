//
// Zig には楽しい配列演算子があります。
//
// '++'を使って2つの配列を連結することができます。
//
//   const a = [_]u8{ 1,2 };
//   const b = [_]u8{ 3,4 };
//   const c = a ++ b ++ [_]u8{ 5 }; // 1 2 3 4 5 になる
//
// 配列の繰り返しに '**' を使用することができます。
//
//   const d = [_]u8{ 1,2,3 } ** 2; // 1 2 3 1 2 3 になる
//
// 注意点
// '++' と '**' 両方とも、プログラムが「コンパイル時」だけ、 配列を操作できる点に注意してください。
// この特別な時間をZigでは「comptime」と呼びます。
// 後ほど詳しく説明します。
//
const std = @import("std");

pub fn main() void {
    const le = [_]u8{ 1, 3 };
    const et = [_]u8{ 3, 7 };

    // (問題 1)
    // 上の2つの配列を連結したものをセットしてください．
    // 想定する結果:  1 3 3 7
    const leet = ???;

    // (問題 2)
    // この配列を繰り返しを使ってセットしてください．
    // 想定する結果: 1 0 0 1 1 0 0 1 1 0 0 1
    const bit_pattern = [_]u8{ ??? } ** 3;

    // さて、これで問題は全部です。結果を見てみましょう。
    //
    // これらの配列をleet[0], leet[1],...と表示することができます。
    // 代わりにZig 'for'ループのプレビューを少し見てみましょう。
    //
    //    for (<itemを保持する配列>) |item| { <itemに対する何らかの処理> }
    //
    // ご心配なく。ループ処理については、次回以降に説明します。
    // 
    //
    std.debug.print("LEET: ", .{});

    for (leet) |n| {
        std.debug.print("{}", .{n});
    }

    std.debug.print(", Bits: ", .{});

    for (bit_pattern) |n| {
        std.debug.print("{}", .{n});
    }

    std.debug.print("\n", .{});
}
