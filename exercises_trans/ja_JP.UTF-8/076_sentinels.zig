//
// センチネルとはデータの終端のことです。
// 大文字の 'S' がセンチネル(終端)となり、
// 小文字のシーケンスの終わりを示すと想像してみよう。
//
//     abcdefS
//
// もしこのシーケンスで大文字も扱えるとしたら，'S' は
// もはや正規の値ではなくなってしまうので、ひどいセンチネルになります。
// シーケンス内の通常の値ではなくなってしまうからです。
//
//     abcdQRST
//          ^-- おっと! シーケンスの最後の文字が R!
//
// 文字列の終わりを示すのによく使われるのは、値 0 です。
// ASCIIとUnicodeはこれを「Null文字」と呼んでいます。
//
// Zig はセンチネルで終端する配列、スライス、ポインタをサポートしています。
//
//     const a: [4:0]u32       =  [4:0]u32{1, 2, 3, 4};
//     const b: [:0]const u32  = &[4:0]u32{1, 2, 3, 4};
//     const c: [*:0]const u32 = &[4:0]u32{1, 2, 3, 4};
//
// 配列 'a' には 5 つの u32 値が格納され、そのうち最後の値は 0 である。
// しかし、コンパイラはこのような細かい処理を行います。
// あなたのために a' を 4 つの項目からなる通常の配列として扱うことができます。
//
//
// スライス 'b' はゼロ終端の配列しか指定できません。
// しかし、それ以外は通常のスライスと同様に動作します。
//
// ポインタ 'c' は練習問題 054 で学習した多項目ポインタと全く同じですが、
// 終端が 0 であることが保証されています。
// この保証のおかげで、この多項目ポインタの長さを知らなくても
// 安全に終端を見つけることができます。
// (通常の多項目ポインタではできません!).
//
// 重要: センチネルの値は，終了するデータと同じ型でなければなりません．
//
//
const print = @import("std").debug.print;
const sentinel = @import("std").meta.sentinel;

pub fn main() void {
    // ここに u32 値のゼロ終端配列があります。
    var nums = [_:0]u32{ 1, 2, 3, 4, 5, 6 };

    // ここにゼロ終端の多項目ポインタがあります。
    var ptr: [*:0]u32 = &nums;

    // 面白いので、3の位置の値をセンチネル値0に置き換えてみましょう。
    // これはちょっとイケナイ感じですね。
    nums[3] = 0;

    // ゼロ終端の配列と多項目ポインタは同じデータを参照します．
    // これら 2 つをループして表示することで
    // 両者がどのように似ていて、どのように違うかを示す。
    //
    // 両者をループして印刷することを試みることで、両者がどのように似ていて、
    // どのように異なっているかを示すことができるはずです。
    //
    // （配列は、中央のセンチネル 0 を含めて完全に印刷されることがわかりました。
    // 多項目ポインタは最初のセンチネル値で停止します)。
    //
    printSequence(nums);
    printSequence(ptr);

    print("\n", .{});
}

// これが私たちの一般的なシーケンス印刷関数です。
// ほぼ完成していますが、いくつか欠けている部分があります。
// それらを修正してください!
fn printSequence(my_seq: anytype) void {
    const my_typeinfo = @typeInfo(@TypeOf(my_seq));

    // my_typeに含まれるTypeInfoはユニオンである。
    // my_seqのどちらの型が渡されたかによって、
    // ArrayまたはPointerフィールドを表示する処理をスイッチで行っている。
    switch (my_typeinfo) {
        .Array => {
            print("Array:", .{});

            // my_seq 内の項目をループする。
            for (???) |s| {
                print("{}", .{s});
            }
        },
        .Pointer => {
            // これをチェックしてみてください - かなりクールです。
            const my_sentinel = sentinel(@TypeOf(my_seq));
            print("Many-item pointer:", .{});

            // センチネルの値にぶつかるまで my_seq のアイテムを
            // ループする。
            var i: usize = 0;
            while (??? != my_sentinel) {
                print("{}", .{my_seq[i]});
                i += 1;
            }
        },
        else => unreachable,
    }
    print(". ", .{});
}
