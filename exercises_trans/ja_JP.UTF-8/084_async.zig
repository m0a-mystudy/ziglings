//
// Six Facts:
//
// 1.関数とそのすべてのデータを呼び出すために、
// プログラムに割り当てられたメモリ空間を「スタックフレーム」と呼びます。
//
//
// 2.キーワード「return」は、現在の関数呼び出しのフレームをスタックから
// 「ポップ」し（もう必要ない）、関数が呼び出された場所に制御を戻す。
//
//
//     fn foo() void {
//         return; // フレームをポップして制御を戻す
//     }
//
// 3. 「return」と同様に、「suspend」キーワードは、
// 関数が呼び出された場所に制御を戻しますが、
// 関数の呼び出し元のフレームは残っているので、後で再び制御を取り戻すことができます。
// これを行う関数は「非同期」関数である。
//
//
//     fn fooThatSuspends() void {
//         suspend {} // 制御を戻すが、フレームはそのままにする
//     }
//
// 4. 非同期コンテキストで任意の関数を呼び出し、後で使用するために
// そのフレームへの参照を取得するには、'async'キーワードを使用します。
//
//     var foo_frame = async fooThatSuspends();
//
// 5. 'async' キーワードを使わずに非同期関数を呼び出すと、
// 非同期関数を呼び出した関数自体が非同期となります! 
// この例では、bar()関数は非同期であるfooThatSuspends()を呼び出すので、
// 現在非同期です。
//
//
//     fn bar() void {
//         fooThatSuspends();
//     }
//
// 6. main()関数は非同期にはできない!
//
// 事実3と4が与えられたとき、このプログラム（事実5と6によって壊れている）
// をどのように修正するか？
//
const print = @import("std").debug.print;

pub fn main() void {
    // 追加のヒント: 何もするつもりがないのに '_' に代入することができます。
    //
    foo();
}

fn foo() void {
    print("foo() A\n", .{});
    suspend {}
    print("foo() B\n", .{});
}
