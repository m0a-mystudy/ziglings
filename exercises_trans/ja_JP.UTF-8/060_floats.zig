//
// Zig は IEEE-754 の浮動小数点数をサポートしており、
// そのサイズは f16, f32, f64, f128 です。
// 浮動小数点リテラルは科学的記法で書くことができます。
//
//     const a1: f32 = 1200.0;     // 1,200
//     const a2: f32 = 1.2e+3;     // 1,200
//     const b1: f32 = -500_000.0; // -500,000
//     const b2: f32 = -5.0e+5;    // -500,000
//
// 16進数の浮動小数点は 'e' という文字が使えないので、
// 代わりに 'p' を使用します。
//
//     const hex: f16 = 0x2A.F7p+3; // わぁ、難解!
//
// 値を格納するのに十分な大きさの float 型を必ず使用してください 
// (有効桁数およびスケールの両方において)。
// 丸め誤魔化してもいいが、大きすぎたり小さすぎたりする数値は 
// inf や -inf (正または負の無限大) になってしまう!
// 
//
//     const pi: f16 = 3.1415926535;   // 3.140625 に丸める．
//     const av: f16 = 6.02214076e+23; // アボガドロ定数は 正の無限大!
//
// float リテラルには、小数点があります。
// 数値リテラルで数学演算を行う場合は、型が一致することを確認してください。
// Zigは安全でない型の強制を裏で行うことはありません。
//
//     var foo: f16 = 13.5 * 5;   // ERROR!
//     var foo: f16 = 13.5 * 5.0; // 問題なし、両方とも浮動小数点数です。
//
// このプログラムの2つの浮動小数点数の問題を修正し
// 結果を整数値で表示してください。

const print = @import("std").debug.print;

pub fn main() void {
    // スペースシャトルの打ち上げ時のおおよその重量（ブースター、燃料タンクを含む）は
    // ブースターと燃料タンクを含む）2,200トンである。
    //
    // この重量をトンからキログラムに換算すると、1トン＝907.18kgとなる。
    // 1トン＝907.18kgで換算する。
    var shuttle_weight: f16 = 907.18 * 2200;

    // デフォルトでは、float 値は科学式でフォーマットされます。
    // 記法でフォーマットされます。'{d}' と '{d:.3}' を使って、
    // 小数点以下の書式がどうなるか試してみてください。
    print("Shuttle liftoff weight: {d:.0}kg\n", .{shuttle_weight});
}

// さらに浮動小数点。
//
// 例として、Zig の f16 は IEEE 754 の「半精度」2進浮動小数点フォーマット
//  ("binary16") であり、メモリにはこのように格納される。
// 
//
//         0 1 0 0 0 0 1 0 0 1 0 0 1 0 0 0
//         | |-------| |-----------------|
//         |  指数部     有効数字
//         |
//          符号
//
// これは、IEEE-754 浮動小数点の桁の格納方法のため、
// f16 で作成できる円周率の表現に最も近いものです。
// 
//
//   * 符号ビット 0 は正の数を表します。
//   * 指数ビット 10000 は 16 のスケールです。
//   * 符号ビット 1001001000 は、10進数値 584 です。
//
// IEEE-754 では、これらの値を変更することでスペースを節約しています。
// 値 01111 は常に指数ビットから引かれ（この場合、10000 - 01111 = 1、
// したがって指数は 2^1）、有効数字は暗黙の 1 の後の 10 進値
// （つまり 10 進法では 1.1001001000 または 1.5703125） になります！
// このため、IEEE-753 では、これらの値を変更することでスペースを節約しています。
// これで、次のようになります。
//
//     2^1 * 1.5703125 = 3.140625
//
// これらの実装の詳細は、すぐに忘れていただいて結構です。
// 知っておくべき重要なことは、浮動小数点数は
// 大きな値や小さな値を格納するのに適していますが
// （f64では宇宙の原子数規模の数を扱うことができます）、
// 桁が丸められることがあり、整数よりも精度が低い結果につながるということです。
// 
//
// 面白いことに、有効数字は「仮数」と表示されることがありますが、
// Donald E. Knuthはそうしないようにと言っています。
//
// C との互換性: c_longdouble という、C の ABI で使用するための 
// Zig 浮動小数点型も存在します。

