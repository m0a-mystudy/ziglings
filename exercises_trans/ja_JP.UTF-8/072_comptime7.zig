//
// 'inline while' もあります。inline for' と同じように、
// コンパイル時にループさせることで、実行時には不可能な様々な面白いことを
// 可能にします。
// このちょっとおかしな例が何を出力しているか分かるかな。
//
//     const foo = [3]*const [5]u8{ "~{s}~", "<{s}>", "d{s}b" };
//     comptime var i = 0;
//
//     inline while ( i < foo.len ) : (i += 1) {
//         print(foo[i] ++ "\n", .{foo[i]});
//     }
//
// まだ魔法使いの帽子は脱いでないんだね？
//
const print = @import("std").debug.print;

pub fn main() void {
    // ここに一連の算術演算と 10 進 1 桁の値を含む文字列があります。
    //  各演算と桁の組を「命令」と呼ぶことにしましょう。
    // 
    const instructions = "+3 *5 -2 *2";

    // ここに u32 変数があり、プログラムの実行時に現在の値を記録します。
    // 0から始まり、上記の一連の命令を実行することで最終的な値を取得します。
    //
    // 
    var value: u32 = 0;

    // この "index" 変数は、ループ内のコンパイル時にのみ使用されます。
    //
    comptime var i = 0;

    // ここでは、コンパイル時に文字列の各「命令」に対してループをかけたい。
    //
    //
    //  1つの "命令 "につき1回ループするように修正してください。
    ??? (i < instructions.len) : (???) {

        // これは、「命令」から数字を取得します。あなたは
        // なぜ'0'を引いているのかわかりますか？
        comptime var digit = instructions[i + 1] - '0';

         // この'switch'ステートメントには、実行時に行われる実際の作業が含まれています。
        //  最初、これはエキサイティングなことではありません...
        switch (instructions[i]) {
            '+' => value += digit,
            '-' => value -= digit,
            '*' => value *= digit,
            else => unreachable,
        }
        // ...しかし、最初に見たときよりもかなりエキサイティングなことです。
        // 'inline while' はもはや実行時には存在せず、
        // 実行時コードに直接触れられないものも存在しない。
        // 例えば 'instructions' という文字列は、
        // コンパイルされたプログラムでは使われないので、どこにも現れません!
        //
        //
        // つまり、このループは実際のところ、文字列に含まれる命令を
        // コンパイル時に実行時コードに変換しているのです。
        // 私たちは今、コンパイラの作者なのです。
        // ほらね？結局のところ、魔法使いの帽子は正当化されたのです。
    }

    print("{}\n", .{value});
}
