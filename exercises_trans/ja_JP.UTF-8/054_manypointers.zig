//
// スライスを使用せずに、複数のアイテムへのポインタを作成することもできます。
//
//     var foo: [4]u8 = [4]u8{ 1, 2, 3, 4 };
//     var foo_slice: []u8 = foo[0..];
//     var foo_ptr: [*]u8 = &foo;
//
// foo_slice と foo_ptr の違いは、スライスの長さが既知であることです。
// ポインターは長さをわかっていません
// foo_ptr が指し示す u8 の個数を追跡するのはあなた自身となります。
//
const std = @import("std");

pub fn main() void {
    // zen12 の文字列を強制する配列の型をよく見てください 
    // (文字列の本当の性質は、いくつかの追加機能を学習したときに明らかになります)。
    // 
    const zen12: *const [21]u8 = "Memory is a resource.";
    //
    //   スライスに強制することも有効です。:
    //         const zen12: []const u8 = "...";
    //
    // ここで、これを「多項目ポインタ(many-item pointer)」にしてみましょう。:
    const zen_manyptr: [*]const u8 = zen12;

    // 配列やスライスと同様に、zen_manyptr にアクセスしてもかまいません。
    // 長さを自分で管理していれば大丈夫です!
    //
    // Zig における「文字列」は、const u8 値の配列へのポインタです
    // （上で見たように、const u8 値のスライスでもかまいません）。
    // つまり、const u8 の「多項目ポインタ」は、それをスライスに変換することができれば、
    // 文字列として扱うことができます。(ヒント: 長さはわかっている!)
    //
    // この行を修正して、下の print 文がこれを出力できるようにしてください。
    const zen12_string: []const u8 = zen_manyptr;

    // ここからが正念場!
    std.debug.print("{s}\n", .{zen12_string});
}
//
// ポインタの型がたくさんあって、混乱してきましたか？
//
//     無料の ZIG POINTER チートシート (u8をサンプル型として使用)
//   +---------------+----------------------------------------------+
//   |  u8           |  1つのu8                                      |
//   |  *u8          |  1つのu8へのポインタ                            | 
//   |  [2]u8        |  u8を2つ                                      |
//   |  [*]u8        |  未知個数の u8 のポインタ                        |
//   |  [*]const u8  |  不変の u8 の未知個数のポインタ                   |
//   |  *[2]u8       |  2個のu8からなる配列へのポインタ                  |
//   |  *const [2]u8 |  2個のu8からなる不変の配列へのポインタ             |
//   |  []u8         |  u8のスライス                                  |
//   |  []const u8   |  不変の u8 のスライス                           |
//   +---------------+----------------------------------------------+
