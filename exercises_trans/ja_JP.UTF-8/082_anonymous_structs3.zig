//
// フィールド名を持たない無名構造体リテラルを作成することもできます。
//
//
//     .{
//         false,
//         @as(u32, 15);
//         @as(i64, 67.12);
//     }
//
// タプルは、名前ではなくインデックスの順序で参照されるフィールドを持つデータ型として、
// 多くのプログラミング言語で使われている用語です。
// これを可能にするために、Zigコンパイラは構造体に数値フィールド名0, 1, 2
// などを自動的に割り当てます。
//
//
// 裸の数字は合法的な識別子ではないので（foo.0は構文エラー）
// @"" 構文で引用する必要がある。
// 例を示します。
//
//     const foo = .{ true, false };
//
//     print("{} {}\n", .{foo.@"0", foo.@"1"});
//
// 上の例では、"true false" と表示されます。
//
// ちょっと待てよ...
//
// .{} が print 関数の求めるものである場合、
// 「タプル」を分解して別のものに入れる必要があるか？いいえ！そうではありません。
// それは冗長です! これは同じものを印刷します。
//
//     print("{} {}\n", foo);
//
// Aha! これで、print()が「タプル」を受け取ることがわかりました。
// これで、物事が本当にうまくいき始めました。
//
const print = @import("std").debug.print;

pub fn main() void {
    // "タプル "です。
    const foo = .{
        true,
        false,
        @as(i32, 42),
        @as(f32, 3.141592),
    };

    // これを実装します。
    printTuple(foo);

        // これはお遊びです、だってできるんだもん。
    const nothing = .{};
    print("\n", nothing);
}

// 汎用的なタプルプリンタを作ってみましょう。これは
// "タプル "を受け取り、各フィールドを以下のフォーマットでプリントアウトする。
//
//     "name"(type):value
//
// 例:
//
//     "0"(bool):true
//
// これを組み立てることになります。しかし、心配しないでください。
// 必要なものはすべてコメントに書かれています。s
fn printTuple(tuple: anytype) void {
    // 1. 入力 'tuple' パラメータでフィールドのリストを取得する。必要である
    //
    //     @TypeOf() - 値を受け取り、その型を返します。
    //
    //     @typeInfo() - 型を受け取り、その型に固有のフィールドを持つ
    //                  TypeInfoユニオンを返す。
    //
    //     構造体型のフィールドのリストはTypeInfoのStruct.fieldsに記載されている。
    // 
    //
    //     例:
    //
    //         @typeInfo(Circle).Struct.fields
    //
    // これはStructFieldsの配列になります。
    const fields = ???;

    // 2. 各フィールドをループする。これはコンパイル時に行う必要があります。
    //
    //
    //     ヒント: 'インライン'ループを覚えていますか？
    //
    for (fields) |field| {
        // 3. フィールドの名前、型、値を表示する。
        //
        //     このループ内の各「フィールド」は、これらのうちの1つです。
        //
        //         pub const StructField = struct {
        //             name: []const u8,
        //             field_type: type,
        //             default_value: anytype,
        //             is_comptime: bool,
        //             alignment: comptime_int,
        //         };
        //
        //     この組み込み関数が必要です。:
        //
        //         @field(lhs: anytype, comptime field_name: []const u8)
        //
        //     第1パラメータはアクセスする値です
        //     第2パラメータはアクセスしたいフィールドの名前を表す文字列。
        //     フィールドの値が返される。
        //
        //     例:
        //
        //         @field(foo, "x"); //  foo.x の値を返す。
        //
        // 最初のフィールドは次のように表示されるはずです。: "0"(bool):true
        print("\"{s}\"({any}):{any} ", .{
            field.???,
            field.???,
            ???,
        });
    }
}
