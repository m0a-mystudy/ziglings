//
// ' comptime' キーワードをいつ使うかを知ることに加えて、
// いつ使う必要がないかを知っておくとよいでしょう。
//
// 以下のコンテキストはすでにコンパイル時に暗黙のうちに評価されており、 
// 'comptime' キーワードを追加することは余計で冗長、かつ無意味なことである。
// 
//
//    * グローバルスコープ（ソースファイル内の任意の関数の外側）
//    * 以下の型宣言:
//        * Variable変数s
//        * 関数（パラメータと戻り値の型）
//        * 構造体 
//        * ユニオン
//        * 列挙
//    * インライン for ループおよび while ループのテスト式
//    *  @cImport() 組み込み関数に渡される式
//
// Zigとしばらく付き合っていると、
// こうした文脈に対する直感が働くようになります。今、それに取り組んでみましょう。
//
// 以下のプログラムでは、'comptime'ステートメントを1つだけ使用するように指示されています。
// これがそれです。
//
//     comptime
//
// たった1つでいいんです。賢く使おう!
//
const print = @import("std").debug.print;

// グローバルスコープにあるため、この値に関するすべての情報は
// この値は暗黙のうちにコンパイル時に知ることが要求されます。
const llama_count = 5;

// ここでも、この値の型とサイズはコンパイル時に知る必要がありますが、
// ここでは関数の戻り値の型からコンパイラに推測させるようにしています。
// 
const llamas = makeLlamas(llama_count);

// そして、これがその関数です。
// 戻り値の型は入力引数の1つに依存することに注意してください!
fn makeLlamas(count: usize) [count]u8 {
    var temp: [count]u8 = undefined;
    var i = 0;

    // これはインラインの while である必要はないことに注意してください。
    while (i < count) : (i += 1) {
        temp[i] = i;
    }

    return temp;
}

pub fn main() void {
    print("My llama value is {}.\n", .{llamas[2]});
}
//
// ここでの教訓は、必要でない限り、
// プログラムに 'comptime' キーワードを散りばめないことです。
// 暗黙のコンパイル時コンテキストと、Zigがコンパイル時に理解できるあらゆる式を
// 積極的に評価することの間で、このキーワードを実際に必要とする場所が
// いかに少ないかに驚かされることがあります。
