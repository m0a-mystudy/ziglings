//
// 配列の受け渡しが厄介であることを見てきました。おそらく、あなたは
// クイズ3の恐ろしい関数定義を覚えているはずです。
// この関数はちょうど4つのアイテムからなる配列しか受け取ることができません。
//
//     fn printPowersOfTwo(numbers: [4]u16) void { ... }
//
// これが配列の問題点として　サイズはデータ型の一部であり、
// そのデータ型のすべての使用法にハードコードされなければなりません。
// この数値配列は [10]u8 であり、永遠に続きます。
// 
//     var digits = [10]u8{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
//
// ありがたいことに、Zig にはスライスがあり、開始アイテムを動的に指定し、長さを指定することができます。
// 以下は、この数値配列のスライスです。
// array:
//
//     const foo = digits[0..1];  // 0
//     const bar = digits[3..9];  // 3 4 5 6 7 8
//     const baz = digits[5..9];  // 5 6 7 8
//     const all = digits[0..];   // 0 1 2 3 4 5 6 7 8 9
//
// 見ての通り、スライス [x..y] は、最初のアイテムのインデックスを x、
// 最後のアイテムを y-1 で開始します。y を省略すると 
// 「残りの項目」を得ることができます。
//
// u8 要素を持つ配列に対するスライスの型は []u8 です。
//
const std = @import("std");

pub fn main() void {
    var cards = [8]u8{ 'A', '4', 'K', '8', '5', '2', 'Q', 'J' };

    // 最初の4枚を手札1に、残りを手札2に入れてください。
    const hand1: []u8 = cards[???];
    const hand2: []u8 = cards[???];

    std.debug.print("Hand1: ", .{});
    printHand(hand1);

    std.debug.print("Hand2: ", .{});
    printHand(hand2);
}

// この関数に手を貸してください。u8スライスの手を、です。
fn printHand(hand: ???) void {
    for (hand) |h| {
        std.debug.print("{u} ", .{h});
    }
    std.debug.print("\n", .{});
}
//
// 面白い事実：内部的には、スライスは最初のアイテムへのポインタ
// と長さを格納します。
