//
// Zigはコンパイル時に暗黙のうちにいくつかの評価を行うことを見てきました。
// しかし、時には、明示的にコンパイル時の評価を要求したいこともあるでしょう。
// そのために、新しいキーワードを用意しました。
//
//  .     .   .      o       .          .       *  . .     .
//    .  *  |     .    .            .   .     .   .     * .    .
//        --o--            comptime        *    |      ..    .
//     *    |       *  .        .    .   .    --*--  .     *  .
//  .     .    .    .   . . .      .        .   |   .    .  .
//
// 変数宣言の前に置かれた 'comptime' は、
// その変数のすべての使用法がコンパイル時に実行されることを保証します。
//
//
// 簡単な例として、以下の2つの文を比べてみてください。
//
//    var bar1 = 5;            // ERROR!
//    comptime var bar2 = 5;   // OKAY!
//
// なぜなら、Zig は変更可能な識別子
// (var で宣言されたもの)がランタイムに使用されると仮定しており、
// ランタイムの型(u8 や f32 など)が割り当てられていないからです。
// 実行時にサイズが確定していない comptime_int を使おうとすると、
// MEMORY CRIME となり、逮捕されます。
//
// 2つ目は、'bar2'がコンパイル時変数であることをZigに伝えたので大丈夫です。
// Zigはこれが正しいことを確認し、間違いがあれば教えてくれる。
//
const print = @import("std").debug.print;

pub fn main() void {
    //
    // この奇妙な例では，変数 count を使って配列を割り当てることにしました．
    // しかし、何かが足りません...
    //
    var count = 0;

    count += 1;
    var a1: [count]u8 = .{'A'} ** count;

    count += 1;
    var a2: [count]u8 = .{'B'} ** count;

    count += 1;
    var a3: [count]u8 = .{'C'} ** count;

    count += 1;
    var a4: [count]u8 = .{'D'} ** count;

    print("{s} {s} {s} {s}\n", .{ a1, a2, a3, a4 });

    // 組み込みBONUS!
    //
    // 組み込み関数compileLog()は、コンパイル時にのみ動作する
    // print文のようなものです。
    // Zigコンパイラは@compileLog()の呼び出しをエラーとして扱うので、
    // コンパイル時のロジックをデバッグするために一時的に使用することになります。
    //
    // この行をアンコメントして、いろいろと弄ってみてください。
    // (コピーしたり、移動したり) してみてください。
    //@compileLog("Count at compile time: ", count);
}
